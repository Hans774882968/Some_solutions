**poj2096**

设dp[i,j]是当前状态（分别已获得i种、j种）到结束的期望次数。dp[n,m] = 0，ans = dp[0,0]，每种状态转移都有一定的概率，由期望的线性性写出
$$
dp[i][j] = 1 + p1 * dp[i][j] + p2 * dp[i + 1][j] + p3 * dp[i][j + 1] + p4 * dp[i + 1][j + 1]
$$
看上去好像有自指，但这公式可以移项的。显然倒着递推即可。然后为了不超出n和m我采用了麻烦的写法。

显然本题可以拓展到任意维，一样移项+倒着递推即可。

**hdu4405**

设dp[i]是当前点到n的期望次数。dp[n] = 0，ans = dp[0]。

我们先把瞬移点预处理好，类似于并查集

```c++
        for(int i = n;i >= 1;i--){
            if(moves[i]){
                int tmp = moves[i];
                for(;moves[tmp] != tmp;tmp = moves[tmp]);
                moves[i] = tmp;
            }
            else moves[i] = i;
        }
```

然后转移公式就是
$$
dp[i] = 1 + 1.0 / 6 * dp[moves[i + j]](j = 1 to 6 and i + j <= n)
$$

**hdu4652**

子问题0：

设dp[i] = 最近已有连续i个相同，到终点还需多少次。dp[n] = 0，dp[0] = ans。
$$
dp[i] = 1 / m * dp[i + 1] + (m - 1) / m * dp[1] + 1
$$
式子存在“循环依赖”，所以必须化简。本题2个子问的套路都是“联立作差”，用i + 1替换i，并相减，得
$$
dp[i] - dp[i + 1] = 1 / m * (dp[i + 1] - dp[i + 2])
$$
刚好得到一个等比数列，又
$$
ans = dp[0] = \sum_{i = 0}^{n - 1}dp[i] - dp[i + 1] = dp[0] - dp[n]
$$

$$
dp[0] - dp[1] = 1（代入i = 0）
$$

于是
$$
ans = \frac{m^{n} - 1}{m - 1}
$$
子问题1：

设dp[i] = 最近已有连续i个不同，到终点还需多少次。dp[n] = 0，dp[0] = ans。
$$
dp[i] = 1 + (m - i) / m * dp[i + 1] + \frac{\sum_{j = 1}^{i}dp[j]}{m}
$$
同样存在“循环依赖”，必须化简。用i + 1替换i，并相减，得
$$
dp[i] - dp[i + 1] = (m - i) / m * dp[i + 1] - (m - i - 1) / m * dp[i + 2] - dp[i + 1] / m
$$
一样设差分数组，化简得
$$
s[i + 1] = m / (m - i - 1) * s[i],s[0] = 1
$$
后面的工作和子问题0完全一样。

//实现的时候发现自己打的getchar()龟读出了锅qwq//

*总结：期望dp写出的式子可能存在“循环依赖”，此时要大胆进行化简。另外期望dp可以是连续型的，那就是微积分题了。*

**spoj-Favorite_Dice**

此题和hdu4652思路相似，设现在已经搞出i个面了，到n个面还需多少次。d[i] = 1 + d[i + 1] * (m - i)  / m + d[i] * i  / m，化简一波即可得到答案，懒得写了。